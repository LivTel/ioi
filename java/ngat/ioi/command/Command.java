// Command.java
// $HeadURL$
package ngat.ioi.command;

import java.io.*;
import java.lang.*;
import java.net.*;
import java.text.SimpleDateFormat;

import ngat.net.TelnetConnection;
import ngat.net.TelnetConnectionListener;
import ngat.util.logging.*;

/**
 * The Command class is the base class for sending a command and getting a reply from the
 * IO:I IDL server socket. This is a telnet - type socket interaction.
 * @author Chris Mottram
 * @version $Revision$
 */
public class Command implements Runnable
{
	/**
	 * Revision Control System id string, showing the version of the Class.
	 */
	public final static String RCSID = new String("$Id$");
	/**
	 * ngat.net.TelnetConnection instance.
	 */
	protected TelnetConnection telnetConnection = null;
	/**
	 * The reply broker in use to decide which command instance receives each reply received over the telnet 
	 * connection.
	 */
	protected CommandReplyBroker replyBroker = null;
	/**
	 * The command to send to the tiptilt.
	 */
	protected String commandString = null;
	/**
	 * Exception generated by errors generated in sendCommand, if called via the run method.
	 * @see #sendCommand
	 * @see #run
	 */
	protected Exception runException = null;
	/**
	 * Boolean set to true, when a command has been sent to the server and
	 * a reply string has been sent.
	 * @see #sendCommand
	 */
	protected boolean commandFinished = false;
	/**
	 * A string containing the reply from the server socket.
	 */
	protected String replyString = null;
	/**
	 * The logger to log messages to.
	 */
	protected Logger logger = null;

	/**
	 * Default constructor. Construct the TelnetConnection and set this object to be the listener.
	 * Constructs the logger.
	 * @see #logger
	 * @see #telnetConnection
	 */
	public Command()
	{
		super();
		telnetConnection = new TelnetConnection();
		//telnetConnection.setListener(this);
		logger = LogManager.getLogger(this);
	}

	/**
	 * Constructor. Construct the TelnetConnection and set this object to be the listener.
	 * Setup the commandString.
	 * @param address A string representing the address of the server socket, i.e. "ioi",
	 *     "localhost", "192.168.1.62"
	 * @param portNumber An integer representing the port number the server socket is receiving command on.
	 * @param commandString The string to send to the C layer as a command.
	 * @see #telnetConnection
	 * @see #commandString
	 * @exception UnknownHostException Thrown if the address in unknown.
	 */
	public Command(String address,int portNumber,String commandString) throws UnknownHostException
	{
		super();
		telnetConnection = new TelnetConnection(address,portNumber);
		//telnetConnection.setListener(this);
		logger = LogManager.getLogger(this);
		this.commandString = commandString;
	}

	/**
	 * Set the telnet connection used for communications to an externally created one.
	 * @param tc The telnet connection.
	 * @see #telnetConnection
	 */
	public void setTelnetConnection(TelnetConnection tc)
	{
		telnetConnection = tc;
	}

	/**
	 * Set the command.
	 * @param command The string to send to the server as a command.
	 * @see #commandString
	 */
	public void setCommand(String command)
	{
		commandString = command;
	}

	/**
	 * Run thread. Uses sendCommand to send the specified command over a telnet connection to the specified
	 * address and port number.
	 * Catches any errors and puts them into runException. commandFinished indicates when the command
	 * has finished processing, replyString contains the server replies.
	 * @see #commandString
	 * @see #sendCommand
	 * @see #replyString
	 * @see #runException
	 * @see #commandFinished
	 */
	public void run()
	{
		try
		{
			logger.log(Logging.VERBOSITY_VERY_VERBOSE,this.getClass().getName()+
				   ":run:Calling sendCommand.");
			sendCommand();
			logger.log(Logging.VERBOSITY_VERY_VERBOSE,this.getClass().getName()+
				   ":run:sendCommand finished.");
		}
		catch(Exception e)
		{
			runException = e;
			commandFinished = true;
		}
	}

	/**
	 * Routine to send the specified command over a telnet connection to the specified
	 * address and port number, wait for a reply from the server, and try to parse the reply.
	 * @exception Exception Thrown if an error occurs.
	 * @see #replyBroker
	 * @see #commandString
	 * @see #commandFinished
	 * @see #parseReplyString
	 */
	public void sendCommand() throws Exception
	{
		logger.log(Logging.VERBOSITY_VERY_VERBOSE,this.getClass().getName()+":sendCommand:Started.");
		commandFinished = false;
		logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+
			   ":sendCommand:Sending Command:"+commandString);
		replyBroker = CommandReplyBroker.getInstance();
		replyBroker.sendCommand(commandString,this);
		while(replyString == null)
		{
			logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+
				   ":sendCommand:Getting synchronisation lock on:"+this);
			synchronized(this)
			{
				logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+
					   ":sendCommand:Awaiting reply.");
				wait(10000);
			}
		}
		logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+
			   ":sendCommand:Received Reply:"+replyString);
		logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+":sendCommand:Parsing reply.");
		parseReplyString();
		logger.log(Logging.VERBOSITY_INTERMEDIATE,this.getClass().getName()+":sendCommand:Reply parsed.");
		commandFinished = true;
		logger.log(Logging.VERBOSITY_VERY_VERBOSE,this.getClass().getName()+":sendCommand:Finished.");
	}

	/**
	 * Parse a string returned from the server over the telnet connection.
	 * @exception Exception Thrown if a parse error occurs.
	 * @see #replyString
	 */
	public void parseReplyString() throws Exception
	{
		if(replyString == null)
		{
			throw new Exception(this.getClass().getName()+
					    ":parseReplyString:Reply string to command '"+commandString+"'was null.");
		}
	}

	/**
	 * Set the reply string. This is normally only called by the CommandReplyBroker.
	 * @param s The FULL reply string returned from the server.
	 * @see #replyString
	 */
	public void setReplyString(String s)
	{
		replyString = s;
	}

	/**
	 * Return the reply string
	 * @return The FULL string returned from the server.
	 * @see #replyString
	 */
	public String getReplyString()
	{
		return replyString;
	}

	/**
	 * Get any exception resulating from running the command.
	 * This is only filled in if the command was sent using the run method, rather than the sendCommand method.
	 * @return An exception if the command failed in some way, or null if no error occured.
	 * @see #run
	 * @see #sendCommand
	 * @see #runException
	 */
	public Exception getRunException()
	{
		return runException;
	}

	/**
	 * Get whether the command has been completed.
	 * @return A Boolean, true if a command has been sent, and a reply received and parsed. false if the
	 *     command has not been sent yet, or we are still waiting for a reply.
	 * @see #commandFinished
	 */
	public boolean getCommandFinished()
	{
		return commandFinished;
	}

	/**
	 * Return whether this command is an interrupt command (one that can be sent at the same time as 
	 * another command is active on the connection) or not.
	 * @return true if the command can be sent at the same time as 
	 *         another command is active on the connection, false otherwise.
	 */
	public boolean isInterruptCommand()
	{
		return false;
	}

	/**
	 * Main test program.
	 * @param args The argument list.
	 */
	public static void main(String args[])
	{
		Command command = null;
		CommandReplyBroker replyBroker = null;
		int portNumber = 1234;

		if(args.length != 3)
		{
			System.out.println("java ngat.ioi.command.Command <hostname> <port number> <command>");
			System.exit(1);
		}
		try
		{
			// setup some console logging
			initialiseLogging();
			// parse arguments
			portNumber = Integer.parseInt(args[1]);
			command = new Command(args[0],portNumber,args[2]);
			// setup telnet connection
			command.telnetConnection.open();
			// ensure reply broker is using same connection
			replyBroker = CommandReplyBroker.getInstance();
			replyBroker.setTelnetConnection(command.telnetConnection);
			command.run();
			command.telnetConnection.close();
			if(command.getRunException() != null)
			{
				System.err.println("Command: Command "+args[2]+" failed.");
				command.getRunException().printStackTrace(System.err);
				System.exit(1);
			}
			System.out.println("Reply:"+command.getReplyString());
			System.out.println("Finished:"+command.getCommandFinished());
		}
		catch(Exception e)
		{
			e.printStackTrace(System.err);
			System.exit(1);
		}

		System.exit(0);
	}

	public static void initialiseLogging()
	{
		Logger l = null;
		LogHandler handler = null;
		BogstanLogFormatter blf = null;
		String loggerNameStringArray[] = {"ngat.ioi.command.AcquireRampCommand","ngat.ioi.command.Command",
						  "ngat.ioi.command.CommandReplyBroker",
						  "ngat.ioi.command.GetConfigCommand",
						  "ngat.ioi.command.InitializeCommand",
						  "ngat.ioi.command.KeywordValueReplyCommand",
						  "ngat.ioi.command.PingCommand",
						  "ngat.ioi.command.PowerDownASICCommand",
						  "ngat.ioi.command.PowerUpASICCommand",
						  "ngat.ioi.command.SetFSModeCommand",
						  "ngat.ioi.command.SetFSParamCommand",
						  "ngat.ioi.command.SetIdleModeOptionCommand",
						  "ngat.ioi.command.SetRampParamCommand",
						  "ngat.ioi.command.SetWindowModeCommand",
						  "ngat.ioi.command.SetWinParamsCommand",
						  "ngat.ioi.command.StandardReplyCommand",
						  "ngat.ioi.command.StopAcquisitionCommand"};
		blf = new BogstanLogFormatter();
		blf.setDateFormat(new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS z"));
		handler = new ConsoleLogHandler(blf);
		handler.setLogLevel(Logging.ALL);
		for(int index = 0; index < loggerNameStringArray.length; index ++)
		{
			l = LogManager.getLogger(loggerNameStringArray[index]);
			l.setLogLevel(Logging.ALL);
			l.addHandler(handler);
		}
	}
}
